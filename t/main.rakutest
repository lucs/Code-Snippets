use v6;
use Test;
use Test::Selector;
use Code::Snippets;

my $snim = / ^^ SNIM /;

my $CS = Code::Snippets.new;

sub get-snip ($text) {
    my ($ok-snip, $got-snip) = Code::Snippets::Snip.build($text, $snim);
    $ok-snip or die "Unexpected failure: '$got-snip'.";
    return $got-snip;
}

sub add-ok ($text) {
    my $snip = get-snip($text);
    my ($ok-add, $got-add) = $CS.add-snip($snip);
    ok($ok-add, "Okay, text added.");
}

sub add-ko ($text, $exp_msg_like) {
    my $snip = get-snip($text);
    my ($ok-add, $got-add) = $CS.add-snip($snip);
    ok(! $ok-add, "Failed, as expected.");
    like($got-add, $exp_msg_like, $exp_msg_like.gist);
}

t a1 => {
    add-ok("SNIM f\n");
    add-ko("SNIM f\n", / Path .* "already exists" /);
    add-ok("SNIM g/\n");
    add-ko("SNIM g/g\n", / Path .* "already exists" /);
};

# --------------------------------------------------------------------
done-testing;
=finish

my $CS = Code::Snippets.new(
);

# --------------------------------------------------------------------
my $CS = {
    my $snips-file = File::Temp.new;
        print $snips-file join '', map {
   #         "^-^ $_\nfoo\n\nbar\n"
   #     } grep /^[^#]/, split /\s+/, $test_data;
   #     close $snips-file;
        return Code::Snippets.new(
   #         snips-file => $snips-file->filename,
   #         id_pfx => qr/^\^-\^ /m,
   #         file_ext => ".x",
        );
}.();

# --------------------------------------------------------------------
sub test-case ($CS, $snal, $exp-leaf, @exp-files) {
    my $snips-dir = $CS.snips-dir;

        # Check for expected leaf.
    is ( $CS.snal_leaf_path($snal), $exp-leaf, "Expect leaf" );

        # Check for presence of expected files.
    $CS->extract($snal);
    while (@exp-files) {
        my $should_have_id_lines = shift @exp-files;
        my $exp-fname = shift @exp-files;
        my $exp-fspec = "$snips-dir/$exp-fname";
        ok(-f $exp-fspec, "Snippet file '$exp-fname' should exist.");
        my $contents = File::Slurp::read_file($exp-fspec);
        like(
            $contents,
            $should_have_id_lines ? qr/^\^-\^ / : qr/^bar/,
            "Contents should be as expected.",
        );
    }
    rmtree($snips-dir) if -d $snips-dir;
}

#test-case($CS, $snal, $exp-leaf, @exp-files);

# --------------------------------------------------------------------
done-testing;
=finish

# --------------------------------------------------------------------
sub ($test_data is copy, *@test_cases) {
    $test_data ~~ s/^\s+//;
    $test_data ~~ s/\s+$//;
        # Build the snippets manager.
    my $CS = {
   #     my $snips-file = File::Temp->new;
   #     print $snips-file join '', map {
   #         "^-^ $_\nfoo\n\nbar\n"
   #     } grep /^[^#]/, split /\s+/, $test_data;
   #     close $snips-file;
        return Code::Snippets.new(
   #         snips-file => $snips-file->filename,
   #         id_pfx => qr/^\^-\^ /m,
   #         file_ext => ".x",
        );
    }.();

   # for my $tc (@test_cases) {
   #     my ($snal, $exp_leaf, @exp_files) = split /\s+/, $tc;
   #     test-case($CS, $snal, $exp_leaf, @exp_files);
   # }
}.(
   '
    a
    .b
    -c
    -.d
    SKIP
    e:E
    SKIP
    f:f/g/h
    -:j/k
    l:j/l
    :j/m
    ',
        # Alias, expected leaf, expected extracted files.
    'a a.x    1 a.x',
    'b b      1 b',
    'c c.x    0 c.x',
    'd d      0 d',
    'e E      1 E',
    'f f/g/h  1 f/g/h',
    'l j/l    0 j/k 1 j/l 1 j/m',
);

# --------------------------------------------------------------------
done-testing;
=finish

sub {
    my ($test_data, @test_cases) = @_;
    $test_data =~ s/^\s+//g;
    $test_data =~ s/\s+$//g;
        # Build the snippets manager.
    my $CS = sub {
        my $snipfile = File::Temp->new;
        print $snipfile join '', map {
            "^-^ $_\nfoo\n\nbar\n"
        } grep /^[^#]/, split /\s+/, $test_data;
        close $snipfile;
        return Code::Snippets->new(
            snipfile => $snips-file->filename,
            id_pfx => qr/^\^-\^ /m,
            file_ext => ".x",
        );
    }->();

    for my $tc (@test_cases) {
        my ($snal, $exp_leaf, @exp_files) = split /\s+/, $tc;
        test-case($CS, $snal, $exp_leaf, @exp_files);
    }
}->(
   '
    a
    .b
    -c
    -.d
    SKIP
    e::
    e:f
    g/
    f:f/g/h
    -:j/k
    l:j/l
    :j/m
    ',
        # Alias, expected leaf, expected extracted files.
    'a a.x    1 a.x',
    'b b      1 b',
    'c c.x    0 c.x',
    'd d      0 d',
    'e E      1 E',
    'f f/g/h  1 f/g/h',
    'l j/l    0 j/k 1 j/l 1 j/m',
);

# --------------------------------------------------------------------
sub {
    try {
        my $CS = sub {
            my $snipfile = File::Temp->new;
            print $snipfile join '', map { "^-^ $_\n" } << 'EoS' =~ /(.*\n)/g;
a/b/c Snippet a.
a/b/c/d/e/f/g Invalid -- can't have both 'a/b/c' and 'a/b/c/...'.
EoS
            close $snipfile;
            return Code::Snippets->new(
                snips-file => $snips-file->filename,
                id_pfx => qr/^\^-\^ /m,
                file_ext => ".x",
            );
        }->();
    }
    catch {
        like($_, qr<'a/b/c' already exists>, "Expect failure.");
    }
}->();

